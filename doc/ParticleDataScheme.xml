<chapter name="The Particle Data Scheme">

<h2>The Particle Data Scheme</h2>

<note>Warning:</note> The handling of particle data has yet to
reach its final form. This is of course true for the whole program,
but in terms of user interaction probably more so here than elsewhere.

<h3>Introduction</h3>

The management of particle data is based on the four classes:
<ul>
<li><code>ParticleDataEntry</code>, which stores the relevant information 
on a  particle species, and</li>
<li><code>ParticleDataTable</code>, which is a map of PDG particle 
<code>id</code> numbers <ref>Boo01</ref> onto the relevant 
<code>ParticleDataEntry</code>.</li> 
<li><code>DecayChannel</code>, which stores info on one particular decay 
mode.</li>
<li><code>DecayTable</code>, which is a vector of 
<code>DecayChannel</code>'s, containing all the decay modes of a 
particle, and also methods for picking a decay mode.</li>
</ul>
These files together form a database that is continuously being used 
as the program has to assign particle masses, decay modes etc.

<p/>
The <code>ParticleDataTable</code> class is purely static, i.e. you 
can interact with it directly by 
<code>ParticleDataTable::command(argument)</code>. 
However, a <code>particleData</code> object of the 
<code>ParticleDataTable</code> class is a public member of the 
<code>Pythia</code> class, so an alternative 
notation would be <code>pythia.particleData.command(argument)</code>, 
assuming that <code>pythia</code> is an instance of the 
<code>Pythia</code> class. Further, for some of the most frequent user 
tasks, <code>Pythia</code> methods have been defined, so that 
<code>pythia.command(argument)</code> 
would work, see further below.

<p/>
A fundamental difference between the <code>ParticleData</code> 
classes and the <code>Settings</code> ones is that the former 
are accessed regularly during the event generation process, as a new 
particle is produced and its mass need to be set, e.g., while 
<code>Settings</code> is mainly/only used at the initialization stage. 
Nevertheless, it is not a good idea to change data in either of them 
in mid-run, since this may lead to inconsistencies. 

<h3>Stored properties</h3>

Currently the following particle properties are stored in the
<code>ParticleDataTable</code> for a given PDG particle identity code 
<code>id</code>, here presented by the name used to access this property: 
<method name="hasAnti(id)">
bool whether a distinct antiparticle exists or not;
</method>
<method name="name(id)">
particle and antiparticle names are stored separately, the sign of 
<code>id</code> determines which of the two is returned, with 
<code>void</code> used to indicate the absence of an antiparticle; 
</method>
<method name="charge3(id)"> 
three times the charge (to make it an integer), alternatively 
<code>charge(id)</code>, which is a double equal to 
<code>charge3(id)/3.</code>;
</method>
<method name="colType(id)">
the colour type, with 0 uncoloured, 1 triplet, -1 antitriplet and 2 octet;
</method>
<method name="m0(id)">
the nominal mass <ei>m_0</ei> (in GeV);
</method>
<method name="constituentMass(id)">
is the constituent mass for a quark, hardcoded as 
<ei>m_u = m_d = 0.325</ei>, <ei>m_s = 0.50</ei>, <ei>m_c = 1.60</ei> 
and <ei>m_b = 5.0</ei> GeV, for a diquark the sum of quark constituent 
masses, and for everything else the same as the ordinary mass
</method>
<method name="width(id)">
the width <ei>Gamma</ei> of the Breit-Wigner distribution (in GeV);
</method>
<method name="range(id)">
the allowed mass range generated by the Breit-Wigner, 
<ei>| m - m_0 | &lt; range</ei> (in GeV);
</method>
<method name="tau0(id)">
the nominal proper lifetime <ei>tau_0</ei> 
(in mm/c); 
</method>
<method name="mayDecay(id)">
a flag telling whether a particle species may decay or not, offering 
the main user switch (whether a given particle of this kind then actually 
will decay also depends on other flags in the <code>ParticleDecays</code> 
class).
</method>
<method name="externalDecay(id)">
a flag telling whether a particle should be handled by an external 
decay package or not, with the latter default 
(<a href="ExternalDecays.xml" target="page">further information</a>).
</method>

<p/>
Similar methods can also be used to set these properties.

<p/>
There are five further methods for output:
<method name="particleDataPtr(id)">
returns a pointer to the <code>ParticleDataEntry</code> object;
</method>
<method name="mass(id)">
returns a mass distributed according to a truncated Breit-Wigner, with 
parameters as above (see also the 
<code>ParticleData:modeBreitWigner</code> switch below);
</method>
<method name="isVisible(), isInvisible()">
particles with/without strong or electromagnetic interactions, which 
thereby are or are not visible in a normal detector.
</method>
<method name="spin(id)">
<ei>2 * s + 1</ei> where known, else 0.
</method>

<p/>
The following properties are stored for each decay channel:
<method name="branchingRatio()">
the branching ratio;
</method>
<method name="modeME()">
the mode of processing this channel, possibly with matrix elements 
(see below);
</method>
<method name="multiplicity()"> 
the number of decay products in a channel, at most 8;
</method>
<method name="product(i)">
a list of the decay products, 8 products 0 &lt;= i &lt; 8,
with trailing unused ones set to 0.
</method>

<p/>
The decay table also defines a few methods:
<method name="addChannel( branchingRatio, modeME, product1, ...)"> 
adds a decay channel with up to 8 products.
</method>
<method name="size()">
gives the number of decay channels for a particle;
</method>
<method name="pick()">
picks one decay channel according to their respective branching ratios;
</method>
<method name="rescaleBR(newSumBR)">
rescale all branching ratios to the provided new sum, 
by default unity. 
</method>

<h3>Operation</h3>

The normal flow of the particle data operations is:

<ol>

<li>When a <code>Pythia</code> object <code>pythia</code> is created, the 
<code>ParticleDataTable</code> member <code>pythia.particleData</code> 
is asked to scan the <code>ParticleData.xml</code> file.</li> 

<li>All lines beginning with <code>&lt;particle></code> are scanned for 
information on a particle species, and all lines beginning with 
<code>&lt;channel></code> are assumed to contain a decay channel of the 
most recent particle. The information stored in a <code>&lt;particle></code> 
line is: id, name, antiparticle name, 3*charge, colour type, nominal mass, 
width, range, nominal proper lifetime, and whether the particle may decay.
The information stored in a <code>&lt;channel></code> is: branching ratio, 
mode, and decay products.   
<note>Important</note>: the values in the <code>.xml</code> file should not 
be changed, except by the PYTHIA authors. Any changes should be done 
with the help of the methods described below.</li> 

<li>Between the creation of the <code>Pythia</code> object and the 
<code>init</code> call for it, you may use the methods of the 
<code>ParticleDataTable</code> class to modify some of the default values. 
Several different approaches can be chosen for this.

<p/> 
a) Inside your main program you can directly set values with
<pre>
    pythia.particleData.readString(string)
</pre>
where both the variable name and the value are contained inside
the character string, separated by blanks and/or a =, e.g. 
<pre>
    pythia.particleData.readString("111:mayDecay = off"); 
</pre>
switches off the decays of the <ei>pi^0</ei>.<br/>    

The particle id (> 0) and the property to be changed must be given, 
separated by a colon.<br/> 

The allowed properties are: <code>name</code>, <code>antiName</code>, 
<code>charge3</code>, <code>colType</code>, <code>m0</code>, 
<code>width</code>, <code>range</code>, <code>tau0</code> and 
<code>mayDecay</code>. All of these names 
are case-insensitive. Names that do not match an existing variable 
are ignored. A warning is printed, however, unless an optional 
second argument <code>false</code> is used. For <code>bool</code> 
values, the following notation may be used interchangeably: 
<code>true = on = yes = ok = 1</code>, while everything else gives 
<code>false</code> (including but not limited to <code>false</code>, 
<code>off</code>, <code>no</code> and 0).<br/> 

A further command is <code>rescaleBR</code>, which rescales each of the
existing branching ratios with a common factor, such that their new
sum is the provided value. This may be a first step towards adding 
new decay channels, see further below.<br/> 

Particle data often comes in sets of closely related information.
Therefore some properties expect the value to consist of several
numbers. These can then be separated either by blanks and/or by
commas. A simple example is <code>names</code>, which expects both the 
name and antiname to be given. A more interesting one is the 
<code>all</code> property,
<pre>  
    id:all = name antiName charge3 colType m0 width range tau0 mayDecay
</pre>
where all the current information on the particle itself is replaced, 
but any decay channels are kept unchanged. Using <code>new</code> instead 
of <code>all</code> also removes any previous decay channels.   

<p/>
Alternatively the <code>id</code> code may be followed by another integer, 
which then gives the decay channel number. This then has to be 
followed by the property specific to this channel, either 
<code>branchingRatio</code>, <code>modeME</code> or <code>products</code>. 
In the latter case all the products of the channel should be given:
<pre>
    id:channel:products =  product1 product2 ....  
</pre>
The line will be scanned until the end of the line, or until a
non-number word is encountered, or until the maximum allowed number
of eight products is encountered, whichever happens first. It is also 
possible to replace all the properties of a channel in a similar way:
<pre>
    id:channel:all = branchingRatio modeME product1 product2 ....  
</pre>
To add a new channel at the end, use
<pre>
    id:addChannel = branchingRatio modeME product1 product2 ....
</pre>
It is currently not possible to remove a channel selectively, but 
setting its branching ratio vanishing is as effective.<br/>

When adding new channels or changing branching ratios is general,
note that, once a particle is to be decayed, the sum of branching 
ratios is always rescaled to unity. Beforehand, <code>rescaleBR</code> may 
be used to rescale an existing branching ratio by the given factor.

<p/>
The <code>Pythia</code> class contains a <code>readString</code> method 
that hand on to this method, or to corresponding methods in 
<code>Settings</code> or Pythia6, and therefore may offer the most 
convenient form, i.e. more compactly:
<pre>
    pythia.readString("111:mayDecay = off"); 
    pythia.readString("15:2:products = 16 -211"); 
</pre>

<p/>
b) Underlying this are commands for all the individual properties in  
the <code>ParticleDataTable</code> class, one for each. Thus, an example 
now reads 
<pre>
    pythia.particleData.mayDecay(111, false);
</pre>
Boolean values should here be given as <code>true</code> or 
<code>false</code>. 

<p/>
c) A simpler and more useful way is to collect all your changes
in a separate file, with one line per change, e.g. 
<pre>
    111:mayDecay = off
</pre>
Each line is process as described for the string in 3a). Since names 
that do not match an existing variable are ignored, you can easily 
comment out lines. The recommended way would be to add a special 
character like # or ! in the first column.<br/>

The file can be read by the 
<pre>
    pythia.particleData.readFile("filename") 
</pre>
method, alternatively by the 
<pre>
    pythia.readFile("filename") 
</pre>
method. The latter has the advantage that it allows you to freely mix 
commands to the <code>Settings</code>, <code>ParticleData</code> and 
<code>Pythia6</code> classes, and so is preferable.</li> 

<li>
A routine <code>reInit("filename")</code> is provided, and can be used to 
zero the particle data table and reinitialize  from scratch. Such a call 
might be required if several <code>Pythia</code> objects are created in the 
same run, and requested to have different values - by default the 
<code>init()</code> call is only made the first time. Several 
<code>pythia</code> with different values would have to run sequentially 
and not in parallel, though; recall that there is only one instance of 
the particle data table.</li> 

<li>You may at any time obtain a listing of all the particle data by 
calling
<pre>
    pythia.particleData.listAll();
</pre>
The listing is by increasing <code>id</code> number. To list only those 
particles that were changed (one way or another, the listing will not
tell what property or decay channel was changed), instead use
<pre>
    pythia.particleData.listChanged();
</pre>
To list only one particle, give its <code>id</code> code as argument to
the <code>list(...)</code> function.. To list a restricted set of particles, 
give in their <code>id</code> codes to <code>list(...)</code> as a 
<code>vector&lt;int></code>.</li> 

</ol>

</chapter>

<!-- Copyright C 2006 Torbjorn Sjostrand -->
