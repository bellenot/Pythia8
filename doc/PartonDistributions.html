<html>
<head>
<title>Parton Distributions</title>
</head>
<body>

<h2>Parton Distributions</h2>

The parton distributions file contains the <code>PDF</code> class (an 
abbreviation hopefully so well accepted that it is used in many places 
of the code, instead of writing it out in full). <code>PDF</code> is the 
base class, from which specific <code>PDF</code> classes are derived.

<p/>
The choice of which PDF to use is made by a switch in the <code>Pythia</code> 
class, see <a href="Generic.html" target="page">here</a>. 
Thus there is no need for a normal user to study this class. The structure 
must be understood when interfacing new PDF's, however. 

<h3>The PDF base class</h3>

<code>PDF</code> defines the interface that all PDF classes should respect.
The constructor requires the incoming beam species to be given:
even if used for a proton PDF, one needs to know whether the beam
is actually an antiproton. This is one of the reasons why <code>Pythia</code> 
always defines two PDF objects in an event, one for each beam.

<p/>
Once a <code>PDF</code> object has been constructed, call it <code>pdf</code>, 
the main method is <code>pdf.xf( id, x, Q2)</code>, which returns 
<i>x*f_id(x, Q2)</i>, properly taking into account whether the beam 
is an antiparticle or not.

<p/>
Whenever the <code>xf</code> member is called with a new flavour, <i>x</i> 
or <i>Q^2</i>, the <code>xfUpdate</code> member is called to do the actual 
updating. This routine may either update that particular flavour or all 
flavours at this <i>(x, Q^2)</i> point. (In the latter case the saved 
<code>id</code> value <code>idSav</code> should be set to 9.) The choice is 
to be made by the producer of a given set, based on what he/she deems most 
effective, given that sometimes only one flavour need be evaluated, and 
about equally often all flavours are needed at the same <i>x</i> and 
<i>Q^2</i>. Anyway, the latest value is always kept in memory. This is 
the other reason why <code>Pythia</code> has one separate <code>PDF</code> 
object for each beam, so that values at different <i>x</i> can be kept 
in memory. 

<h3>Derived classes</h3>

There is only one pure virtual method, <code>xfUpdate</code>, that therefore 
must be implemented in any derived class. Currently the list of such 
classes is tiny:

<p/>
For protons:
<ul>
<li>GRV94L gives the GRV 94 L parametrization [<a href="References.html" target="page">Glu95</a>].</li>
<li>CTEQ5L gives the CTEQ 5 L parametrization [<a href="References.html" target="page">Lai00</a>].</li>
</ul>
The default is CTEQ 5L, which is the most recent of the two.

<p/>
For charged leptons (e, mu, tau): 
<ul>
<li>Lepton gives a QED parametrization [<a href="References.html" target="page">Kle89</a>].
In QED there are not so many ambiguities, so here one set should be 
enough. On the other hand, there is the problem that the 
lepton-inside-lepton pdf is integrably divergent for <i>x -> 1</i>, 
which gives numerical problems. Like in PYTHIA 6, the pdf is therefore
made to vanish for <i>x > 1 - 10^{-10}</i>, and scaled up in the range
<i>1 - 10^{-7} &lt; x &lt; 1 - 10^{-10}</i> in such a way that the 
total area under the pdf is preserved.</li>
</ul>   

</body>
</html>

<!-- Copyright C 2006 Torbjorn Sjostrand -->
