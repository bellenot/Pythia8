<chapter name="The Les Houches Accord">

<h2>The Les Houches Accord</h2>

The Les Houches Accord for user processes [1] is the standard way to 
input parton-level information from a matrix-elements based generator 
into PYTHIA. The conventions for which information should be stored
has been defined in a Fortran context, as two commonblocks. Here a 
C++ equivalent is defined, as two separate classes.

<p/>
The <code>LHAinit</code> and <code>LHAevnt</code> classes are base classes, 
containing reading and printout functions, plus a pure virtual function 
each. Derived classes have to provide these two virtual functions to do 
the actual work. Currently the only derived classes are for reading 
information from the respective Fortran commonblock or for reading
it from PYTHIA 6.4-produced files. 

<p/>
Normally, pointers to objects of the derived classes should be handed
in with the <code>pythia.init()</code> method. (If you use the LHA 
interface to PYTHIA 6.4, this is taken care of 
internally, so no pointers need to be handed in.) 

<h3>Initialization</h3>

The <code>LHAinit</code> class stores information equivalent to the 
<code>/HEPRUP/</code> commonblock, as required to initialize the event 
generation chain. The main difference is that the vector container 
now allows a flexible number of subprocesses to be defined. For the 
rest, names have been modified, since the 6-character-limit does not 
apply, and variables have been regrouped for clarity, but nothing 
fundamental.

<p/>
The pure virtual function <code>set()</code> has to be implemented in the 
derived class, to set relevant information when called. It should
return <code>false</code> if it fails to set the info.

<p/>
Inside <code>set()</code>, such information can be set by the following 
methods:
<method name="beamA( identity, energy, pdfGroup, pdfSet)"> 
sets the properties of the first incoming beam (cf. the Fortran
<code>IDBMUP(1), EBMUP(1), PDFGUP(1), PDFSUP(1)</code>), and similarly 
a <code>beamB</code> method exists. The parton distribution information 
defaults to zero, meaning that internal sets are used.
</method>
<method name="strategy( choice)"> 
sets the event weighting and cross section  strategy 
(cf. <code>IDWTUP</code>).
</method>
<method name="process( idProcess, crossSection, crossSectionError, 
crossSectionMaximum)"> 
sets info on an allowed process (cf. <code>LPRUP, XSECUP, XERRUP, 
XMAXUP</code>). 
Each new call will append one more entry to the list of processes.
</method>

<p/>
Information is handed back by the following methods:
<method name="idBeamA(), eBeamA(), pdfGroupBeamA(), pdfSetBeamA()">
and similarly with <ei>A -> B</ei>, for the two beam particles.
</method>
<method name="strategy()">
for the strategy choice.
</method>
<method name="size()"> 
for the number of subprocesses.
</method>
<method name="idProcess(i), xSec(i), xErr(i), xMax(i)"> 
for process <code>i</code> in the range <code>0 &lt;= i &lt; 
size()</code>.   
</method>

<p/>
The information can also be printed using the overloaded 
&lt;&lt; operator, e.g. <code>cout &lt;&lt; LHAinitObject</code>.

<h3>Event input</h3>

The <code>LHAevnt</code> class stores information equivalent to the 
<code>/HEPEUP/</code> commonblock, as required to hand in the next 
parton-level configuration for complete event generation. The main 
difference is that the vector container now allows a flexible number 
of partons to be defined. For the rest, names have been modified, 
since the 6-character-limit does not apply, and variables have been 
regrouped for clarity, but nothing fundamental.

<p/>
The Les Houches standard is based on Fortran arrays beginning with
index 1, and mother information is defined accordingly. In order to 
be compatible with this convention, the zeroth line of the C++ particle
array is kept empty, so that index 1 also here corresponds to the first
particle. One small incompatibility is that the <code>size()</code> 
method returns the full size of the particle array, including the 
empty zeroth line, and thus is one larger than the true number of 
particles (<code>NUP</code>). 

<p/>
The pure virtual function <code>set()</code> has to be implemented in 
the derived class, to set relevant information when called. It should
return <code>false</code> if it fails to set the info, e.g. if the 
supply of events in a file is exhausted.

<p/>
Inside <code>set()</code>, cuch information can be set by the following
methods:
<method name="process( idProcess, weight, scale, alphaQED, alphaQCD)"> 
tells which kind of process occured, with what weight, at what scale, 
and which <ei>alpha_EM</ei> and <ei>alpha_strong</ei> were used
(cf. <code>IDPRUP, XWTGUP, SCALUP, AQEDUP, AQCDUP</code>). This method 
also resets the size of the particle list, and adds the empty zeroth 
line, so it has to be called before the particle method below.
</method>
<method name="particle( id, status, mother1, mother2, colourTag1, 
colourTag2, p_x, p_y, p_z, e, m, tau, spin)"> 
gives the properties of the next particle handed in (cf. <code>IDUP, ISTUP, 
MOTHUP(1,..), MOTHUP(2,..), ICOLUP(1,..), ICOLUP(2,..),  PUP(J,..), 
VTIMUP, SPINUP</code>) .
</method>

<p/>
Information is handed back by the following methods:
<method name="idProc(), weight(), scale(), alphaQED(), alphaQCD()">.
</method>
<method name="size()">
for the size of the particle array, which is one larger than the number 
of particles in the event, since the zeroth entry is kept empty 
(see above).
</method>
<method name="id(i), status(i), mother1(i), mother2(i), col1(i), col2(i),
px(i), py(i), pz(i), e(i), m(i), tau(i), spin(i)"> 
for particle <code>i</code> in the range 
<code>0 &lt;= i &lt; size()</code>. (But again note that 
<code>i = 0</code> is an empty line, so the true range begins at 1.)   
</method>

<p/>
The information can also be printed using the overloaded 
&lt;&lt; operator, e.g. <code>cout &lt;&lt; LHAevntObject</code>.

<h3>A runtime Fortran interface</h3>

The <code>LHAinitFortran</code> class derives from <code>LHAinit</code>. 
It reads initialization information from the Les Houches standard 
Fortran commonblock, assuming this commonblock behaves like an 
<code>extern "C" struct</code> named <code>heprup_</code>. (Note the final
underscore, to match how the gcc compiler internally names Fortran
files.) 

<p/>
Initialization is with
<pre>
    LHAinitFortran lhaInit();
</pre>
i.e. does not require any arguments. 

<p/>
The <code>LHAevntFortran</code> class derives from <code>LHAevnt</code>. 
It reads information on the next event, stored in the Les Houches 
standard Fortran commonblock, assuming this commonblock behaves like 
an <code>extern "C" struct</code> named <code>hepeup_</code>.

<p/>
Initialization is with
<pre>
    LHAevntFortran lhaEvnt();
</pre>
i.e. does not require any arguments. 

<p/>
See further the page on "Accessing PYTHIA 6 Processes" for information 
how PYTHIA 6.4 can be linked to make use of this facility. 
Several of the example main programs illustrate how it can be used. 

<h3>An interface to PYTHIA 6 files</h3>

The <code>LHAinitPythia6</code> class derives from <code>LHAinit</code>. 
It reads initialization information, written from PYTHIA 6.4
with the <code>PYUPIN</code> routine, from a given file. The file name 
should be given as argument at the instantiation, e.g.
<pre> 
    LHAinitPythia6 lhaInit("ttsample.init");
</pre>

<p/>
Thw <code>LHAevntPythia6</code>class derives from <code>LHAevnt</code>. 
It reads information on the next event, written from PYTHIA 6.4 with 
the <code>PYUPEV</code> routine, from a given file. The file name should be 
given as argument at the instantiation, e.g. 
<pre> 
    LHAevntPythia6 lhaEvnt("ttsample.evnt");
</pre> 

<p/>
The <code>PYUPEV</code> routine writes mother indices using the Fortran 
(and Les Houches) convention of the first particle being number 1, 
and so matches the C++ "fix" of an empty zeroth particle.  

<p/>
An example how to use events in such exernal files is found in 
<code>main02.cc</code>.

<h3>Other examples</h3>

A special <code>strategy = 10</code> (not present in the <code>IDWTUP</code> 
specification) has been added. It takes a given partonic input, 
no questions asked, and hadronizes it, i.e. does string fragmentation 
and decay. Thereby the normal process-level and parton-level machineries 
are bypassed, to the largest extent possible. (Some parts are used, 
e.g. first to translate the Les Houches event to the process record 
and later to the event record.) Such an option can therefore be used 
to feed in ready-made parton-level configurations, without needing to 
specify where these come from, i.e. there need be no beams or any such 
explicit information, but of course the user must have taken care of it
beforehand. 

<p/>
An example how this can be used for toy studies is found in 
<code>main03.cc</code>.

<h3>References</h3>

<ol>
<li>E. Boos et al., in the Proceedings of the Workshop on Physics at 
TeV Colliders, Les Houches, France, 21 May - 1 Jun 2001 
[hep-ph/0109068]</li>
</ol>

</chapter>

<!-- Copyright C 2006 Torbjorn Sjostrand -->
